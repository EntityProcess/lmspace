description: Evaluation for subagent-run prompt
grader: llm_judge

testcases:
- id: parallel-independent-queries
  outcome: Correctly explains how to process two independent queries in parallel according to the SubagentRunner workflow
  messages:
    - role: user
      content:
        - type: file
          value: /prompts/subagent-run.prompt.md
        - type: text
          value: |-
            Given these two queries:
            1. how is CLAUDE.md used in VS Code.
            2. what is the logic for autoapplying copilot instructions
            
            Explain how you would process these queries according to the SubagentRunner workflow.
    - role: assistant
      content: |-
        I would process these queries in parallel because they are independent:
        
        1. Find relevant prompt: primaryInstructionPath = findRelevantPrompt(userContext, "**/*.prompt.md")
        2. Extract import paths: importPaths = extractImportPaths(primaryInstructionPath)
        3. Determine strategy: #runSubagent available → strategy = "runSubagent"
        4. Parse queries: parseQueries(userInput) → ["how is CLAUDE.md used in VS Code", "what is the logic for autoapplying copilot instructions"]
        5. Analyze dependencies: analyzeQueryDependencies() → no dependencies, single execution group
        6. Execute both queries in parallel:
           - runSubagent("how is CLAUDE.md used in VS Code", files=importPaths)
           - runSubagent("what is the logic for autoapplying copilot instructions", files=importPaths)
        7. Read results: readResult(dispatch, "runSubagent") for each dispatch
        8. Emit results in original order (1, 2)
        
        The total execution time would be approximately equal to the slowest query, not the sum of both, demonstrating true parallel execution.

- id: fallback-to-lmspace-command
  outcome: Falls back to lmspace command when runSubagent tool is not available
  messages:
    - role: user
      content:
        - type: file
          value: /prompts/subagent-run.prompt.md
        - type: text
          value: |-
            Given these two queries:
            1. what is DSPy.
            2. how can we use DSPy to optimize prompts used for agentic coding.
            
            Explain how you would process these queries according to the SubagentRunner workflow when the runSubagent tool is not available in the environment.
    - role: assistant
      content: |-
        I would process these queries using the lmspace CLI fallback since the runSubagent tool is not available:
        
        1. Find relevant prompt: primaryInstructionPath = findRelevantPrompt(userContext, "**/*.prompt.md")
        2. Extract import paths: importPaths = extractImportPaths(primaryInstructionPath)
        3. Determine strategy: #runSubagent NOT available → strategy = "lmspaceCLI"
        4. Parse queries: parseQueries(userInput) → ["what is DSPy.", "how can we use DSPy to optimize prompts used for agentic coding."]
        5. Analyze dependencies: analyzeQueryDependencies() → Query 2 depends on Query 1, create two sequential groups
        6. Execute Group 1:
           - dispatchQuery(primaryInstructionPath, "what is DSPy.", importPaths)
           - wait(initialWaitInterval = 30 seconds)
           - readResult(dispatch, "lmspaceCLI") and emit result
        7. Execute Group 2:
           - dispatchQuery(primaryInstructionPath, "how can we use DSPy to optimize prompts used for agentic coding.", importPaths)
           - wait(subsequentWaitInterval = 15 seconds)
           - readResult(dispatch, "lmspaceCLI") and emit result
        
        The system uses lmspace CLI with synchronous wait barriers when the runSubagent tool is not available.

- id: prompt-not-available-tool-available
  outcome: Uses runSubagent tool even when custom DSPy prompt is not available in workspace
  messages:
    - role: user
      content:
        - type: file
          value: /prompts/subagent-run.prompt.md
        - type: text
          value: |-
            Given these two queries:
            1. what is DSPy.
            2. how can we use DSPy to optimize prompts used for agentic coding.
            
            Explain how you would process these queries according to the SubagentRunner workflow when there is no DSPy prompt available in the workspace, but the runSubagent tool is available.
    - role: assistant
      content: |-
        I would process these queries using the runSubagent tool since it's available, even though there's no custom DSPy prompt:
        
        1. Try to find relevant prompt: findRelevantPrompt(userContext, "**/*.prompt.md") → returns null/empty (prompt not found)
        2. Fallback: generateDynamicInstructions(userContext) to create default instructions
        3. Extract import paths: extractImportPaths(primaryInstructionPath) → returns empty array (no imports)
        4. Check strategy: #runSubagent available → select "runSubagent" strategy
        5. Parse the two queries from the user input
        6. Call analyzeQueryDependencies() to determine Query 2 depends on Query 1
        7. Execute sequentially due to dependency using runSubagent:
           - runSubagent("what is DSPy.", files=[])
           - Wait for response, then runSubagent("how can we use DSPy to optimize prompts used for agentic coding.", files=[])
        8. Emit results in original order (1, 2)
        
        The system uses the runSubagent tool regardless of whether a custom prompt exists in the workspace.

- id: pass-import-paths-not-contents
  outcome: Passes import file paths to runSubagent without reading file contents in main agent context
  messages:
    - role: user
      content:
        - type: file
          value: /prompts/subagent-run.prompt.md
        - type: text
          value: |-
            Given this query that requires research skill:
            "Research how VS Code extensions are structured"
            
            The primary instruction has an import statement:
            import { research } from "../contexts/research-skill.md"
            
            Explain how you handle the import when dispatching to a subagent using runSubagent tool.
    - role: assistant
      content: |-
        When handling imports with the runSubagent tool, I follow the critical constraint to NEVER read import file contents:
        
        1. Find primary instruction: findRelevantPrompt() → returns path to instruction file
        2. Extract import paths: extractImportPaths() → returns ["/contexts/research-skill.md"] as path strings
        3. Check tool availability: isRunSubagentAvailable() → returns true
        4. Dispatch WITHOUT reading files:
           runSubagent(
             query="Research how VS Code extensions are structured",
             files=["/path/to/instruction.md", "/contexts/research-skill.md"]
           )
        
        Key points:
        - importPaths is an array of file path strings, NOT file contents
        - The main agent does NOT read the import files
        - The files parameter passes absolute paths as strings
        - The subagent reads the file contents internally
        
        This follows the constraint: "NEVER read import file contents in main agent context - pass paths only"